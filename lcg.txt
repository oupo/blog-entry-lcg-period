
** はじめに

一部界隈の皆さんはよくご存知の線形合同法数列
	a_0 = F mod 2^32 (Fは初期シード)
	a_{n+1} = (0x41c64e6d * a_n + 0x6073) mod 2^32

は最大周期となることが知られています。
すなわちa_1, a_2, ... と進めていって a_{2^32}で初めてa_0と等しくなります。
なぜそんなことがいえるのでしょうか。またどういう条件のときに最大周期になるのでしょうか。

** 問題

線形合同法数列
	a_0 = F mod M
	a_{n+1} = (A a_n + B) mod M
が最大周期となる条件はなにか。

この記事ではMが4以上の2の累乗のときを扱いましょう。つまりsを2以上の整数としてM = 2^sと表せるときです。
(M = 2のときも含めると後に場合分けが必要になるので省きました。ご都合主義です^^;)

** 具体例
まずは実際にA, B, M, Fに具体的な値を入れて数列を眺めてみましょう。

a_0 = 0, a_{n+1}=(5 a_n + 1) mod 8
|*n|*0|*1|*2|*3|*4|*5|*6|*7|*8|*9|
|*a_n|<b>0</b>|1|6|7|4|5|2|3|<b>0</b>|1|
a_0 = 0, a_{n+1}=(5 a_n + 2) mod 8
|*n|*0|*1|*2|*3|*4|*5|*6|*7|*8|*9|
|*a_n|<b>0</b>|2|4|6|<b>0</b>|2|4|6|<b>0</b>|2|
a_0 = 1, a_{n+1}=(5 a_n + 2) mod 8
|*n|*0|*1|*2|*3|*4|*5|*6|*7|*8|*9|
|*a_n|<b>1</b>|7|5|3|<b>1</b>|7|5|3|<b>1</b>|7|
a_0 = 0, a_{n+1}=(4 a_n + 1) mod 8
|*n|*0|*1|*2|*3|*4|*5|*6|*7|*8|*9|
|*a_n|<b>0</b>|1|5|5|5|5|5|5|5|5|

<!--
[
[8, 5, 1, 0], [8, 5, 2, 0],  [8, 5, 2, 1],  [8, 4, 1, 0], 
].each{|(m, a, b, f)|
  puts "a_0 = #{f}, a_{n+1}=(#{a} a_n + #{b}) mod #{m}"
  puts "|*n|"+10.times.map{|n|"*#{n}"}.join("|")+"|"
  s = f % m
  print "|*a_n|" ;10.times{ print s == f ? "<b>#{s}</b>|" : "#{s}|"; s = (a * s + b) % m };print"\n"
}
-->

** F=0としても一般性は失われない
実はA, B, Mの3つが決まれば、初期シードFによらず最大周期になるかどうかは決まります。
これを証明すれば、後の議論においてF = 0の場合だけ考えればよいことになり楽できます。

それを証明するための準備として周期に関する性質をまとめておきます。

*** 周期に関する性質

具体的なところから、線形合同法数列a_nがa_4で初めてa_0の値に戻ってくるものとします。数列の項の具体的な値は今は重要ではないのでa, b, c, dとしましょう。

ここで重要になってくるのは線形合同法数列がもつ、a_i = a_jならばa_{i+1} = a_{j+1}という性質です。

数列の項の変化を図に表すと次のようになりますね。

(図)

ここでa_0, a_1, a_2, a_3の値にダブりはあるでしょうか？　ありません。
まず、a_1, a_2, a_3のいずれかがa_0に等しいとすると「a_4で初めてa_0の値に戻る」ということに反するのでありえません。
次にa_1, a_2, a_3の中でダブりがあるとするとそこでループができてしまって二度とa_0の値には戻ってきません。
たとえばa_1 = a_3のとき次のようになります。

(図)

以上の議論は周期が4以外のときも成り立ちます。これは直感的理解のための説明です。ちゃんとした証明も難しくはありませんが、この記事では省略します。

上記の説明の通り、線形合同法数列a_nがa_Mで初めてa_0の値に戻ってくるとき、a_0, a_1, a_2, ..., a_Mは互いに異なります。
ここでa_0, a_1, a_2, ..., a_Mは互いに異なるのだからこれらはM個の値からなります。数列a_nは0以上M未満であるM個の整数の中からとるのですから、a_0, a_1, a_2, ..., a_Mには0以上M未満の整数が一つずつ現れるといえます。

*** F=0としても一般性は失われないことの証明

任意のf_1, f_2について、F = f_1で最大周期となるならばF = f_2で最大周期となることを証明すればよいです。

なぜならこれが正しいとすると、
f_1=0, f_2=fをあてはめて、F = 0で最大周期ならばF = fで最大周期であること …①がいえ、
f_1=f, f_2=0をあてはめて、F = fで最大周期ならばF = 0で最大周期であること …②がいえます。

するとF = 0で最大周期でないかつF = fで最大周期だと仮定すると、②よりF = 0のとき最大周期となって矛盾します。よってF = 0のとき最大周期でないならば、F = fのとき最大周期でないといえます。 … ②'

|F = 0で最大周期である|ならば|F = fで最大周期である| … ①より|
|F = 0で最大周期でない|ならば|F = fで最大周期でない| … ②'より|

よって「F = 0で最大周期である」と「F = fで最大周期である」ことの真偽は一致するのです。
対偶を知っている人にはしつこい説明になったかもしれません^^;

さて、任意のf_1, f_2について、F = f_1で最大周期となるならばF = f_2で最大周期となることを証明しましょう。
F=f_1のときの数列をa_n, F=f_2のときの数列をb_nとします。

a_nは最大周期となるのだから、「周期に関する性質」よりa_i = f_2 mod M, 0 <= i < Mとなる整数iが存在しますね。
a_i = b_0 であり、二つの数列の漸化式は同じなのだから任意のkについてa_{i+k} = b_kといえます。

えーここでもちゃんとした証明がめんどくさくなったので^^;、図を使った直感的な説明に逃げます。

(図)

これを見るとa_iからa_{i+M-1}までにダブりがない、すなわちb_0からb_{M-1}までにダブりがない。また、a_i = a_{i+M}すなわちb_0 = b_Mだと直感的理解ができますね。

よって数列b_nは最大周期になります。
したがって、任意のf_1, f_2について、F = f_1で最大周期となるならばF = f_2で最大周期となるといえます。

F=0としても一般性は失われないことが示されましたので、以降からはF=0の場合だけ考えましょう。

** 一般項

まずa_nは必ず0以上M未満の整数となりますから a_n = (a_n mod M)が常に成り立ちます。
ここで数列a_nの一般項を求めてみましょう。

実際に最初の数項を観察してみると

いずれもMを法として
	a_0 = 0
	a_1 = A * a_0 + B = B
	a_2 = A * a_1 + B = A * B + B = (A + 1) B
	a_3 = A * a_2 + B = A * (A + 1) B + B = (A^2 + A + 1) B

より
	a_n = (1 + A + ... + A^{n-1}) B (mod M)
と予想できます。この予想が正しければ、

	a_n mod M = ((1 + A + ... + A^{n-1}) B) mod M
	よって a_n = ((1 + A + ... + A^{n-1}) B) mod M (a_n = a_n mod M より)

となります。
つまり一般項は a_n = ((1 + A + ... + A^{n-1}) B) mod M と予想できますね。
この予想は数学的帰納法で簡単に証明できます。（省略）

** Bが偶数のとき？
突然ですが、Bが偶数であるとするとどうなるでしょう。
Mも偶数なのでa_nは常に偶数となってしまいます。(a_nが(偶数)をMで割った余りでありa_n = (偶数) - M * (商)と表せるから)
しかし、最大周期のときa_0, a_1, ..., a_{M-1}は0からM-1までのすべての整数をとるはずだったので、Bが偶数だとこれに反しますね。
よって、Bが偶数のときは最大周期になりません。

** Aが偶数のとき？
二つの異なる項の次の項が同じになることから矛盾を導くか。
それともA^nでnが一定値を越すと2^sの倍数になっちゃって、一定値がずっと続いてしまうことを説明するか。

やっぱ
最大周期のとき a_i = a_j <=> i == j (mod M)
を示しておいた方がいいのかどうか…

*** 証明1
Aが偶数かつ最大周期だと仮定します。
A = 2A' とおくと A^s = (2A')^s = (2^s)(A^s)よりn >= sのときA^nはMの倍数となります。
Mの倍数の違いはMで割った余りには影響しませんから、
	a_{s} = ((1 + A + ... + A^{s-1}) B) mod M
	a_{s+1} = ((1 + A + ... + A^{s-1} + A^{s}) B) mod M
	a_{s+2} = ((1 + A + ... + A^{s-1} + A^{s} + A^{s+1}) B) mod M
	...
はすべて等しくなります。よってs以上のMの倍数のひとつMkをとるとa_{Mk} = a_{Mk+1}ですから、a_0 = a_1となります。矛盾しました。

*** 証明2
Aが偶数かつ最大周期だと仮定します。
ここで周期に関する性質よりa_i = M/2, 0 <= i < Mを満たす整数iがあります。M/2!=0だからi=0はないですね。
Aは2の倍数だからA a_iはMの倍数となります。
Mの倍数の違いはMで割った余りには影響しませんから、
a_{i+1} = (A a_i + B) mod M
        = B mod M
よってa_{i+1} = a_1 です。a_1, a_2, ..., a_Mは互いに異なりますから矛盾しました。（これはa_0, a_1, ..., a_{M-1}が互いに異なることとa_M = a_0からすぐ分かります）

さて、AかBのどちらか少なくとも一方が偶数のときは最大周期にならないことは分かったので、以降ではA、Bともに奇数である場合を調べましょう。

** a_n = 0という条件

最大周期となるというのは、a_Mで初めてa_0の値に戻ってくるということでした。
つまりa_M = 0かつ1 <= n < M であるすべてのnについてa_n != 0であるということです。

ということはnに対してa_nが0になるかどうかが重要になります。a_n = 0であるかどうかという条件を変形していきましょう。

	a_n = 0 <=> ((1 + A + ... + A^{n-1}) B) mod M = 0
	        <=> (1 + A + ... + A^{n-1}) B = 0 (mod M)
	        <=> (1 + A + ... + A^{n-1}) B がMの倍数
	        <=> (1 + A + ... + A^{n-1}) B が2^sの倍数
	        <=> (1 + A + ... + A^{n-1}) が2^sの倍数 (Bは奇数より)

よって (1 + A + ... + A^{n-1}) が2の何乗で割れるかに注目しましょう。

正整数xが2^kで割り切れるような最大のkを v_2(x) で表すことにします。

D_A(n) = (1 + A + ... + A^{n-1}) とおきます。

するとa_n = 0 <=> v_2(D_A(n)) >= s となります。

** v_2(D_A(n))を観察する

ここで v_2(D_A(n)) が実際どうなるのか具体的に見てみましょう。

A=3のとき

|*n|*D_A(n)|*v_2(D_A(n))|
|1|1=1|0|
|2|1+3=4|2|
|3|1+3+3^2=13|0|
|4|1+3+3^2+3^3=40|3|
|5|1+3+3^2+3^3+3^4=121|0|
|6|1+3+3^2+3^3+3^4+3^5=364|2|
|7|1+3+3^2+3^3+3^4+3^5+3^6=1093|0|
|8|1+3+3^2+3^3+3^4+3^5+3^6+3^7=3280|4|
|9|1+3+3^2+3^3+3^4+3^5+3^6+3^7+3^8=9841|0|
|10|1+3+3^2+3^3+3^4+3^5+3^6+3^7+3^8+3^9=29524|2|

<!--
(1..10).each do|n| 
  x = (0..n-1).map{|k| k == 0 ? "1" : k == 1 ? "3" : "3^#{k}" }.join("+")
  r = (0..n-1).map{|k| 3**k }.inject(:+)
  puts "|#{n}|#{x}=#{r}|#{v_2(r)}|"
end
-->

こうしてみると、v_2(D_A(n))はv_2(n)と関係がありそうですね。

|*n|*v_2(n)|*v_2(D_A(n))|
|1|0|0|
|2|1|2|
|3|0|0|
|4|2|3|
|5|0|0|
|6|1|2|
|7|0|0|
|8|3|4|
|9|0|0|
|10|1|2|

nが偶数のときはv_2(D_A(n)) = v_2(n) + 1、nが奇数のときはv_2(D_A(n)) = 0となっていそうです。

nが奇数のとき0になるのは当たり前ですね。奇数を奇数個集めた和は奇数になりますから。
よってnが偶数の場合のみを追ってA=3以外も試してみます。さすがにAが大きくなると計算が大変になるのでコンピュータに計算させました^^;
v_2(D_A(n))の表
|*A＼n|*2|*4|*6|*8|*10|
|*3|2|3|2|4|2|
|*5|1|2|1|3|1|
|*7|3|4|3|5|3|
|*9|1|2|1|3|1|
|*11|2|3|2|4|2|
|*13|1|2|1|3|1|
|*15|4|5|4|6|4|
|*17|1|2|1|3|1|
|*19|2|3|2|4|2|
|*21|1|2|1|3|1|
|*23|3|4|3|5|3|
|*25|1|2|1|3|1|
|*27|2|3|2|4|2|
|*29|1|2|1|3|1|
|*31|5|6|5|7|5|

これを見ると何かにv_2(n)を足した結果がv_2(D_A(n))になっていそうですね。
v_2(n)を引いた結果を表にしてみると

v_2(D_A(n)) - v_2(n)の表
|*A＼n|*2|*4|*6|*8|*10|
|*3|1|1|1|1|1|
|*5|0|0|0|0|0|
|*7|2|2|2|2|2|
|*9|0|0|0|0|0|
|*11|1|1|1|1|1|
|*13|0|0|0|0|0|
|*15|3|3|3|3|3|
|*17|0|0|0|0|0|
|*19|1|1|1|1|1|
|*21|0|0|0|0|0|
|*23|2|2|2|2|2|
|*25|0|0|0|0|0|
|*27|1|1|1|1|1|
|*29|0|0|0|0|0|
|*31|4|4|4|4|4|

<!--
(3..31).select(&:odd?).each do |a|
  puts "|*#{a}|"+(1..10).select(&:even?).map {|n| count_factor_two(sum(a, n)) - count_factor_two(n) }.join("|")+"|"
end
-->

これを見るとどうやら
A mod 4 = 1 のときは v_2(D_A(n)) - v_2(n) = 0
A mod 4 = 3 のときは v_2(D_A(n)) - v_2(n) = v_2(A+1) - 1
のようです。


まとめますと、
|*nが奇数のとき|v_2(D_A(n)) = 0|
|*nが偶数でA mod 4 = 1のとき|v_2(D_A(n)) = v_2(n)|
|*nが偶数でA mod 4 = 3のとき|v_2(D_A(n)) = v_2(n) + v_2(A+1) - 1|
ということです。

しかしこれはAやnが小さいときの結果からの予想に過ぎないので、実際にすべてのAやnで成り立つことは証明しないといけません。

** もし予想が正しいなら…？
予想の証明はなかなか手ごわそうなので、その前にもし予想が正しいならどうなるか見てみましょう。

a_n = 0となる条件がv_2(D_A(n)) >= sでしたね。

*** A mod 4 = 1のとき
nが偶数ならv_2(D_A(n)) = v_2(n)でnが奇数ならv_2(D_A(n)) = 0ですが、これはv_2(D_A(n)) = v_2(n)と一つにまとめられますね。

1 <= n < M (= 2^s) であるすべてのnについてnは2^sで割り切れないので、v_2(n) < s よって v_2(D_A(n)) < s より a_n != 0です。
n = Mのときv_2(n) = sよりa_n = 0です。

よって数列は最大周期となります！

*** A mod 4 = 3のとき
nが偶数のときv_2(D_A(n)) = v_2(n) + v_2(A+1) - 1でした。
A+1は4の倍数となりますからv_2(A+1) >= 2です。

n=2^{s-1}を代入しましょう。（ここでs>=2としている伏線が回収されました^^;これによってnは偶数になります！）
v_2(D_A(2^{s-1})) = v_2(2^{s-1}) + v_2(A+1) - 1
                  = (s - 1) + v_2(A+1) - 1
                  = s + (v_2(A+1) - 2)
                  >= s
となるのでa_{2^{s-1}} = 0となります。0 < 2^{s-1} < Mですから最大周期にはなりません。
