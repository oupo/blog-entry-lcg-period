
** はじめに

一部界隈の皆さんはよくご存知の線形合同法数列
	a_0 = F mod 2^32 (Fは初期シード)
	a_{n+1} = (0x41c64e6d * a_n + 0x6073) mod 2^32

は最大周期となることが知られています。
すなわちa_1, a_2, ... と進めていって a_{2^32}で初めてa_0と等しくなります。
なぜそんなことがいえるのでしょうか。またどういう条件のときに最大周期になるのでしょうか。

** 問題

線形合同法数列
	a_0 = F mod M
	a_{n+1} = (A a_n + B) mod M
が最大周期となる条件はなにか。

この記事ではMが4以上の2の累乗のときを扱いましょう。つまりsを2以上の整数としてM = 2^sと表せるときです。
(M = 2のときも含めると後に場合分けが必要になるので省きました。ご都合主義です^^;)

** 具体例

(TODO)

** F=0としても一般性は失われない
実はA, B, Mの3つが決まれば、初期シードFによらず最大周期になるかどうかは決まります。
これを証明すれば、後の議論においてF = 0の場合だけ考えればよいことになり楽できます。

それを証明するための準備として周期に関する性質をまとめておきます。

*** 周期に関する性質

具体的なところから、線形合同法数列a_nがa_4で初めてa_0の値に戻ってくるものとします。数列の項の具体的な値は今は重要ではないのでa, b, c, dとしましょう。
数列の項の変化を図に表すと次のようになりますね。

(図)

ここでa_0, a_1, a_2, a_3に同じ値が複数回現れることがあるでしょうか？　ありません。
まず、a_1, a_2, a_3のいずれかがa_0に等しいとすると「a_4で初めてa_0の値に戻る」ということに反するのでありえません。
次にa_1, a_2, a_3の中で同じ値が複数回現れるとするとそこでループができてしまって二度とa_0の値には戻ってきません。
たとえばa_1 = a_3のとき次のようになります。

(図)

以上の議論は周期が4以外のときも成り立ちます。
これは直感的理解のための説明です。ちゃんとした証明も難しくはありませんが、この記事では省略します。

上記の説明の通り、線形合同法数列a_nがa_Mで初めてa_0の値に戻ってくるとき、a_0, a_1, a_2, ..., a_Mは互いに異なります。
a_0, a_1, a_2, ..., a_Mは互いに異なるのだからこれらはM個の値からなります。数列a_nは0以上M未満であるM個の整数の中からとるのですから、a_0, a_1, a_2, ..., a_Mには0以上M未満の整数が一つずつ現れるといえます。


** 一般項
まずa_nは必ず0以上M未満の整数となりますから a_n = (a_n mod M)が常に成り立ちます。
ここで数列a_nの一般項を求めてみましょう。

実際に最初の数項を観察してみると

いずれもMを法として
	a_0 = 0
	a_1 = A * a_0 + B = B
	a_2 = A * a_1 + B = A * B + B = (A + 1) B
	a_3 = A * a_2 + B = A * (A + 1) B + B = (A^2 + A + 1) B

より
	a_n = (1 + A + ... + A^{n-1}) B (mod M)
と予想できます。この予想が正しければ、

	a_n mod M = ((1 + A + ... + A^{n-1}) B) mod M
	よって a_n = ((1 + A + ... + A^{n-1}) B) mod M (a_n = a_n mod M より)

と一般項 a_n = ((1 + A + ... + A^{n-1}) B) mod M が予想できますね。
この予想は数学的帰納法で簡単に証明できます。

** a_n = 0という条件

最大周期となるというのは、a_Mで初めてa_0の値に戻ってくるということでした。
つまりa_M = 0かつ1 <= n < M であるすべてのnについてa_n != 0であるということです。

ということはnに対してa_nが0になるかどうかが重要になります。a_n = 0であるかどうかという条件を変形していきましょう。

	a_n = 0 <=> ((1 + A + ... + A^{n-1}) B) mod M = 0
	        <=> (1 + A + ... + A^{n-1}) B = 0 (mod M)
	        <=> (1 + A + ... + A^{n-1}) B がMの倍数
	        <=> (1 + A + ... + A^{n-1}) B が2^sの倍数

A, Bが奇数であることが必要条件であることを示すには数列の周期に関する性質がいるか…

** aaa
A, Bが奇数であることは証明済みとする

	a_n = 0 <=> (1 + A + ... + A^{n-1}) が2^sの倍数
ですから (1 + A + ... + A^{n-1}) が2の何乗で割れるかに注目しましょう。

正整数xが2^kで割れるような最大のkを v_2(x) で表すことにします。

D(n) = (1 + A + ... + A^{n-1}) とおきます。

するとa_n = 0 <=> v_2(D(n)) >= s となります。


ここで v_2(D(n)) が実際どうなるのか具体的に見てみましょう。

A=3のとき

|*n|*D(n)|*v_2(D(n))|
|1|1=1|0|
|2|1+3=4|2|
|3|1+3+3^2=13|0|
|4|1+3+3^2+3^3=40|3|
|5|1+3+3^2+3^3+3^4=121|0|
|6|1+3+3^2+3^3+3^4+3^5=364|2|
|7|1+3+3^2+3^3+3^4+3^5+3^6=1093|0|
|8|1+3+3^2+3^3+3^4+3^5+3^6+3^7=3280|4|
|9|1+3+3^2+3^3+3^4+3^5+3^6+3^7+3^8=9841|0|
|10|1+3+3^2+3^3+3^4+3^5+3^6+3^7+3^8+3^9=29524|2|

<!--
(1..10).each do|n| 
  x = (0..n-1).map{|k| k == 0 ? "1" : k == 1 ? "3" : "3^#{k}" }.join("+")
  r = (0..n-1).map{|k| 3**k }.inject(:+)
  puts "|#{n}|#{x}=#{r}|#{v_2(r)}|"
end
-->

こうしてみると、v_2(D(n))はv_2(n)と関係がありそうですね。

|*n|*v_2(n)|*v_2(D(n))|
|1|0|0|
|2|1|2|
|3|0|0|
|4|2|3|
|5|0|0|
|6|1|2|
|7|0|0|
|8|3|4|
|9|0|0|
|10|1|2|

nが偶数のときはv_2(D(n)) = v_2(n) + 1、nが奇数のときはv_2(D(n)) = 0となっていそうです。

nが奇数のとき0になるのは当たり前ですね。奇数を奇数個集めた和は奇数になりますから。
よってnが偶数の場合のみを追ってA=3以外も試してみます。さすがにAが大きくなると計算が大変になるのでコンピュータに計算させました^^;
v_2(D(n))の表
|*A＼n|*2|*4|*6|*8|*10|
|*3|2|3|2|4|2|
|*5|1|2|1|3|1|
|*7|3|4|3|5|3|
|*9|1|2|1|3|1|
|*11|2|3|2|4|2|
|*13|1|2|1|3|1|
|*15|4|5|4|6|4|
|*17|1|2|1|3|1|
|*19|2|3|2|4|2|
|*21|1|2|1|3|1|
|*23|3|4|3|5|3|
|*25|1|2|1|3|1|
|*27|2|3|2|4|2|
|*29|1|2|1|3|1|
|*31|5|6|5|7|5|

これを見ると何かにv_2(n)を足した結果がv_2(D(n))になっていそうですね。
v_2(n)を引いた結果を表にしてみると

v_2(D(n)) - v_2(n)の表
|*A＼n|*2|*4|*6|*8|*10|
|*3|1|1|1|1|1|
|*5|0|0|0|0|0|
|*7|2|2|2|2|2|
|*9|0|0|0|0|0|
|*11|1|1|1|1|1|
|*13|0|0|0|0|0|
|*15|3|3|3|3|3|
|*17|0|0|0|0|0|
|*19|1|1|1|1|1|
|*21|0|0|0|0|0|
|*23|2|2|2|2|2|
|*25|0|0|0|0|0|
|*27|1|1|1|1|1|
|*29|0|0|0|0|0|
|*31|4|4|4|4|4|

<!--
(3..31).select(&:odd?).each do |a|
  puts "|*#{a}|"+(1..10).select(&:even?).map {|n| count_factor_two(sum(a, n)) - count_factor_two(n) }.join("|")+"|"
end
-->

これを見るとどうやら
A mod 4 = 1 のときは v_2(D(n)) - v_2(n) = 0
A mod 4 = 3 のときは v_2(D(n)) - v_2(n) = v_2(A+1) - 1
のようです。


まとめますと、
|*nが奇数のとき|v_2(D(n)) = 0|
|*nが偶数でA mod 4 = 1のとき|v_2(D(n)) = v_2(n)|
|*nが偶数でA mod 4 = 3のとき|v_2(D(n)) = v_2(n) + v_2(A+1) - 1|
ということです。

しかしこれはAやnが小さいときの結果からの予想に過ぎないので、実際にすべてのAやnで成り立つことは証明しないといけません。

